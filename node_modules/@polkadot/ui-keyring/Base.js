"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _testing = _interopRequireDefault(require("@polkadot/keyring/testing"));

var _util = require("@polkadot/util");

var _accounts = _interopRequireDefault(require("./observable/accounts"));

var _addresses = _interopRequireDefault(require("./observable/addresses"));

var _contracts = _interopRequireDefault(require("./observable/contracts"));

var _development = _interopRequireDefault(require("./observable/development"));

var _Browser = _interopRequireDefault(require("./stores/Browser"));

var _defaults = require("./defaults");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class Base {
  constructor() {
    this._accounts = void 0;
    this._addresses = void 0;
    this._contracts = void 0;
    this._keyring = void 0;
    this._genesisHash = void 0;
    this._store = void 0;
    this._ss58Format = void 0;

    this.decodeAddress = (key, ignoreChecksum, ss58Format) => {
      return this.keyring.decodeAddress(key, ignoreChecksum, ss58Format);
    };

    this.encodeAddress = (key, ss58Format) => {
      return this.keyring.encodeAddress(key, ss58Format);
    };

    this._accounts = _accounts.default;
    this._addresses = _addresses.default;
    this._contracts = _contracts.default;
    this._keyring = undefined;
  }

  get accounts() {
    return this._accounts;
  }

  get addresses() {
    return this._addresses;
  }

  get contracts() {
    return this._contracts;
  }

  get keyring() {
    if (this._keyring) {
      return this._keyring;
    }

    throw new Error('Keyring should be initialised via \'loadAll\' before use');
  }

  get genesisHash() {
    return this._genesisHash;
  }

  getPair(address) {
    return this.keyring.getPair(address);
  }

  getPairs() {
    return this.keyring.getPairs().filter(pair => _development.default.isDevelopment() || pair.meta.isTesting !== true);
  }

  isAvailable(_address) {
    const accountsValue = this.accounts.subject.getValue();
    const addressesValue = this.addresses.subject.getValue();
    const contractsValue = this.contracts.subject.getValue();
    const address = (0, _util.isString)(_address) ? _address : this.encodeAddress(_address);
    return !accountsValue[address] && !addressesValue[address] && !contractsValue[address];
  }

  isPassValid(password) {
    return password.length > 0 && password.length <= _defaults.MAX_PASS_LEN;
  }

  setSS58Format(ss58Format) {
    this._ss58Format = ss58Format;
  }

  setDevMode(isDevelopment) {
    _development.default.set(isDevelopment);
  }

  initKeyring(options) {
    const keyring = (0, _testing.default)(_objectSpread({
      ss58Format: this._ss58Format
    }, options), true);

    if ((0, _util.isBoolean)(options.isDevelopment)) {
      this.setDevMode(options.isDevelopment);
    }

    this._keyring = keyring;
    this._genesisHash = options.genesisHash && options.genesisHash.toHex();
    this._store = options.store || new _Browser.default();
    this.addAccountPairs();
  }

  addAccountPairs() {
    this.keyring.getPairs().forEach(({
      address,
      meta
    }) => {
      this.accounts.add(this._store, address, {
        address,
        meta
      });
    });
  }

  addTimestamp(pair) {
    if (!pair.meta.whenCreated) {
      pair.setMeta({
        whenCreated: Date.now()
      });
    }
  }

}

exports.default = Base;